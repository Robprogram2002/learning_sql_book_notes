##### Grouping and Aggregates

Sometimes you will want to find trends in your data that will require the database server to cook the data a 
bit before you can generate the results you are looking for.

When grouping data, you may need to filter out undesired data from your result set based on groups of data rather 
than based on the raw data. Since the group by clause runs after the where clause has been evaluated, you cannot 
add filter conditions to your where clause for this purpose

Instead, you must put your group filter conditions in the having clause. 

## Aggregate Functions

Aggregate functions perform a specific operation over all rows in a group. Although every database server has 
its own set of specialty aggregate functions, the common aggregate functions implemented by all major servers 
include:

    max() Returns the maximum value within a set 
    min() Returns the minimum value within a set 
    avg() Returns the average value across a set 
    sum() Returns the sum of the values across a set
    count() Returns the number of values in a set   

Example: 

SELECT MAX(amount) max_amt, 
    MIN(amount) min_amt, 
    AVG(amount) avg_amt, 
    SUM(amount) tot_amt, 
    COUNT(*) num_payments 
FROM payment;

In the previous example, every value returned by the query is generated by an aggregate function. 
Since there is no group by clause, there is a single, implicit group (all rows in the payment table).

In most cases, however, you will want to retrieve additional columns along with columns generated by aggregate 
functions. What if, for example, you wanted to extend the previous query to execute the same five aggregate 
functions for each customer, instead of across all customers? For this query, you would want to retrieve the 
customer_id column along with the five aggregate functions

While it may be obvious to you that you want the aggregate functions applied to each customer found in the payment 
table, this query fails because you have not explicitly specified how the data should be grouped. Therefore, you will
 need to add a group by clause to specify over which group of rows the aggregate functions should be applied:

    SELECT customer_id,
        MAX(amount) max_amt, 
        MIN(amount) min_amt, 
        AVG(amount) avg_amt, 
        SUM(amount) tot_amt, 
        COUNT(*) num_payments 
    FROM payment
    GROUP BY customer_id;

When using the count() function to determine the number of members in each group, you have your choice of counting 
all members in the group or counting only the distinct values for a column across all members of the group.

For example, consider the following query, which uses the count() function with the customer_id column in two different 
ways:

    SELECT COUNT(customer_id) num_rows, 
    COUNT(DISTINCT customer_id) num_customers 
    FROM payment;

The first column in the query simply counts the number of rows in the payment table, whereas the second column examines 
the values in the customer_id column and counts only the number of unique values


## Using Expressions

Along with using columns as arguments to aggregate functions, you can use expressions as well
For example, you may want to find the maximum number of days between when a film was rented and subsequently returned. 
You can achieve this via the following query:

    SELECT MAX(datediff(return_date,rental_date)) FROM rental;

The datediff function is used to compute the number of days between the return date and the rental date for every 
rental, and the max function returns the highest value

While this example uses a fairly simple expression, expressions used as arguments to aggregate functions can be as 
complex as needed, as long as they return a number, string, or date.

## How Nulls Are Handled

When performing aggregations, or, indeed, any type of numeric calculation, you should always consider how null 
values might affect the outcome of your calculation.

Even with the addition of the null value to the table, the sum(), max(), and avg() functions all return the same 
values, indicating that they ignore any null values encountered. The difference is that count(*) counts the number 
of rows, whereas count(val) counts the number of values contained in the val column and ignores any null values 
encountered.

## Generating Groups

Examples of common data manipulations include:

    • Generating totals for a geographic region, such as total European sales 
    • Finding outliers, such as the top salesperson for 2020 
    • Determining frequencies, such as the number of films rented in each month

To answer these types of queries, you will need to ask the database server to group rows together by one or more 
columns or expressions.

--- Single-Column Grouping

--- Multicolumn Grouping

--- Grouping via Expressions

Along with using columns to group data, you can build groups based on the values generated by expressions. Consider 
the following query, which groups rentals by year:

    SELECT extract(YEAR FROM rental_date) year, COUNT(*) how_many 
    FROM rental
    GROUP BY extract(YEAR FROM rental_date);

--- Generating Rollups



